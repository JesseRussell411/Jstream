//                   ,▄▄██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▓▄╖
//                ,▄███████▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀███████▄
//              ╓██████▄▒▒▒▒▒▄▄▄▄▒▒▒▒▒▄▄▄▄▒▒▒░▒▄▄▄▄▒▒▒▒▒▄▄▄▄▄▒▒▒▒▄▄▄▄▄▒▒▒▒▄▄▄▄▄▒▒▒▒▄▄▄▄▄▒▒▒▒▄▄▄▄▄░▒▒▒▒▄▄▄▄▒▒▒▒▒▄▄▄▄▒▒▒▒▒▄▄▄▄▒▒▒▒▒▄▄▄▄▒▒▒▒▒▄▄▄▄▒▒▒▒▒▄▄▄▄▒▒▒▒▒▄▄▄▄▒▒▒▒▒▄▄▄▄▒▒▒▒▒▄▄▄▄▄▒▀████▄
//             ▄███▓▒▒▀▀███▓▄▄░▀▀███▓▄▄▒░▀███▓▄▄▒░▀████▄▄▒░▀████▄▄▒░▀▀███▄▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒▒▀▀███▓▄▒▒▀▀███▓▄▒░▀▀███▓▄▄▒▀▀███▓▄▄▒░▀████▄▄▒░▀████▄▄▒░▀▀███▓████▄
//            ████░▀███▓▄▄▒▒▀████▄▄▒▒▀▀███▄▄▒▒▀▀███▄▄▒░▀▀███▄▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒▒▀▀███▓▄▒▒▀▀███▓▄▄▒▀▀███▓▄▄▒▒▀███▓▄▄▒▒▀████▄▄▒▒▀▀███▄▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▒▀███▌
//           ▐███░▒▒▒▒░░▀▀▀▀╨▒▒░░▀▀▀▀▀▒▒░░▀▀▀▀▀▒▒░░▀▀▀▀▀▒▒▒░▀▀▀▀▀▒▒▒░▀▀▀▀▀▒▒▒░▀▀▀▀▀▒▒▒░▀▀▀▀▀▒▒▒░▀▀▀▀▀▒▒▒░▒▀▀▀▀╣▒▒░▒▀▀▀▀╨▒▒░▒▀▀▀▀╬▒▒░░▀▀▀▀╨▒▒░░▀▀▀▀╨▒▒░░▀▀▀▀▀▒░░░▀▀▀▀▀▒▒░░▀▀▀▀▀▒▒▒░▀▀▀▀▀▒▒▐███U
//           ███▌▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▄▄░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒███▌
//           ███▌▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▓███████▄▒▒▒▒▒▒▒▄▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓██▓
//           ███▌▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▄██████░▒▒░░░▒▒░███▀░▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▄▄▄▄▄▄▒▒▒▒▒▒▄▄▄▄▄▒▒▒░▒▒▒▒▄▄▄▄▄░▒▒▒▒▒▄▄▄▄▄▒▒▒▒▒▒▒▒▄▄▄▄▄▄▄▄▄▄▄▒▒▒▒▒▒▒▒▒▒▒▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▒▒▒▒▒▒▒▄▄▄▄▄▄▄▄▄▄▄▄▄▒▒▒▒▒▒▒▒▒░▒▓██▓
//           ███▌▒▒▒▒▒░▒▒▒▒▒▒▒▒███████▒▒▒▒▒▒▒░▒███▄▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒░▒▒██████▒▒▒▒▒▐█████▒▒░▒▒░▒▓██████▒▒▒▒░█████▌▒▒▒▒▒▒▐█████████████▓░▒▒▒▒▒▒░███████████████▒▒▒▒▒░▐███████████████░▒▒▒▒▒▒░▒▓██▓
//           ███▌▒▒▒▒▒▒▒▒▒▒▒██████▓▀████▄▒░░▒▒▄█████▄██▓░▒▒▒▒▒▒▒▒▒░▒▒██████▒▒▒▒▒▐█████▒▒░▒▒░▒▓███████▓▒▒▒█████▌▒▒▒▒▒▒▐█████▀▀▀▀██████▒▒▒▒▒▒░██████░░░░░░░░░▒▒▒▒▒░▐█████▌▒░░▒█████▌░▒▒▒▒▒░▒▓██▓
//           ███▌▒▒▒▒▒░░▒▒▒▒░▀███▒▒▒▒░▀███▄▒▓██████▀▀▀░▒▒▒▒▒▒▒▒▒▒▒░▒▒██████▒▒▒▒▒▐█████▒▒░▒▒░▒▓█████████▒░█████▌▒▒▒▒▒▒▐█████░░░▒░█████▓▒▒▒▒▒░██████▄▓▓▓▓▓▓▄▒▒▒▒▒▒░▐█████▌▄▄▄▄█████▌▒▒▒▒▒▒░▒▓██▓
//           ███▌▒▒▒▒▒▒▒▒▒▒▒▒▒░░░▒▒▒▒░▒░▀███████▀░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒██████▒▒░▒▒▐█████▒▒░▒▒░▒▓████▓█████▌█████▌▒▒▒▒▒▒▐█████▒▒░▒▒██████▒░▒▒▒░██████████████▒░▒▒▒▒░▐█████████████▀▒▒▒▒▒▒▒▒░▒▓██▓
//           ███▌▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▒██████▓░▒▒▒▒░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓█████▒▒▒▒▒▐█████▒▒▒▒▒░▒▓████▌▒▀█████████▌▒▒▒▒▒▒▐█████▒▒▒▒▒█████▓▒▒▒▒▒░██████▒░░░░░░░▒▒▒▒▒▒░▐█████▌▀██████▌▒▒▒▒▒▒▒▒░▒▓██▓
//           ███▌▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▄▄▄██████▀███▓▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▐██████▄▄▄▄██████▒░▒▒▒░▒▓████▌▒▒░████████▌▒▒▒▒▒▒▐█████▄▄▄▄██████▒▒▒▒▒▒░██████▄▄▄▄▄▄▄▄▄░▒▒▒▒░▐█████▌▒▒▀██████░▒▒▒▒▒▒░▒▓██▓
//           ███▌▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒╫█████████░▒▒▒░████▄▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█████████████▀░▒▒▒▒▒▒░▓████▓▒▒░▒▀██████▌▒▒▒▒▒▒▐█████████████▀░▒▒▒▒▒▒▒███████████████▒▒▒▒▒▒▐█████▌▒▒▒▒██████░▒▒▒▒▒░▒▓██▓
//           ███▌▒▒▒▒▒▒▒▒▒▒▒▒░▒▒█▀░▒░▀██▓▒▒▒▒▒▒▒░▀█▀▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▀▀▀▀▀▀▀▀▀░▒▒▒▒▒▒▒▒▒▒▒▀▀▀▀▀▒░░▒▒░▀▀▀▀▀▒▒▒▒▒▒▒░▀▀▀▀▀▀▀▀▀▀▀░▒▒▒▒▒▒▒▒▒▒▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▒▒▒▒▒▒░▀▀▀▀▀▒▒▒▒▒░▀▀▀▀▀▀▒▒▒▒▒▒▒▓██▓
//           ███▌▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▓██▒▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▓██▓
//           ███▌▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒╨▀▀▒░▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒░▒▓██▓
//           ███▌▒░▒▒▒▒▒▄▄▓▓▓▓▄▒▒▒▒░▒▒▄▄▓▓▓▓▄▒▒░▒▒▒▄▄▄▄▒▒▒▒▄▄▄▄▒▒▒▒▄▓▓▓▓▓▄▒▒▒▄▄▓▓▄▄▄▄▄▄▄▄▒▒▄▄▄▄▄▓▓▄▄▄▒▒▒▒▄▓▄▒▒▒▒▒▄▄▄▄▒░░▒▒▄▄▓▓▓▄▄▒▒▒╫▄▄▄▄▄▄▄▄▄▄▄▒▒▄▄▄▓░░░▒▒▒▄▓▓▓▓▄▄▒▒▒▒▒▄▄▓▄░▒▒▒╫▄▓▓▒▒▒▒░▒▓██▓
//           ███▌░░▒▒▒▓██████████▒▒▒▓██████████▄▒▒▓████▓▒▒▒████▒▒▓███▀▀████▌▒████████████▌▒███████████▌▒▐███▌▒▒▒▒████▒▒▒██████████▓▒▓███████████▌▒████▒▒▒▄██████████▓▒▒▒█████▒▒▒▓███▒▒▒▒░▒▓██▓
//           ███▌▒░▒▒╫███▓░▒▒░▀▀▀░▒▓███▌▒▒▒░████▒▒▓██████▄▒████▒▒█████▓▓▓▒▒░▒▒▒▒▒████▒▒▒▒▒▒████▒▒▒▓███▌▒▐███▌▒▒▒▒████▒▒████▒▒▒▒▒▀▀░▒▒▒▒▒▓███▌▒▒░▒░████▒▒▐████░▒▒░▓███▓▒▒██████▓▒▓███░▒▒▒░▒▓██▓
//           ███▌▒░░▒████▌▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▓███▌▒▓███▀████████▒▒░▀▀███████▓▒▒░▒░████▒▒▒▒▒▒██████████▒▒▒▐███▌░░▒▒████▒▒████▒▒░▒▒▒▒▒▒▒▒▒▒▓███▌▒▒░▒░████▒▒╫███▌▒▒▒▒▐████▒▒███▓████████░▒▒▒░▒▓██▓
//           ███▌▒▒▒▒▐████▒▒▒▄███▌▒▓███▓▒▒▒▄████░▒▓███▒░▓██████▒╫███▌▒▒░████▒▒▒▒░████▒▒▒▒▒▒████▒░████▓▒▒▐████▒▒▒▓███▓▒░████▌▒▒▒▓███▒▒▒▒▒▓███▌▒▒░▒░████▒▒▒████▄▒▒▒████▌▒▒███▓▒▀██████░▒▒▒░▒▓██▓
//           ███▌▒▒▒▒▒▒█████████▀▒▒▒▀██████████░▒▒▓███▒▒▒▒█████▒▒▀█████████▀▒▒▒▒▒████▒▒▒▒▒▒████▒▒░█████▒▒▀█████████▓░▒▒▒▀█████████▀▒▒▒▒▒▓███▌▒▒░▒▒████▒▒▒░██████████▀▒▒▒███▓▒▒░█████▒▒▒▒▒▒▓██▓
//           ███▌▒░▒▒▒▒▒░░▀▀▀░░░▒▒▒▒▒░░░▀▀▀▀░▒▒▒▒▒░░░░░▒▒▒░░░░░▒▒▒░░░▀▀▀░░▒▒▒▒▒▒▒░░░░░▒▒▒▒▒░░░░▒▒▒▒░░░░░▒▒▒░░▀▀▀▀▒░▒▒▒▒▒▒▒░░▀▀▀░░▒▒▒▒░░▒░░░░░▒▒▒░░░░░░░▒▒▒▒░░▀▀▀▀░░▒▒▒▒░░░░░▒▒▒▒░░░░▒▒▒▒▒▒███▌
//           ▓███▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒███▌
//            ███▓▒░▀▀███▓▄▒░▀▀███▓▄▒▒▀▀███▓▄▒▒▀▀███▓▄▄▒▒▀███▓▄▄▒▒▀███▓▄▄▒░▀████▄▄▒▒▀▀███▄▄▒░▀▀███▓▄▒▒▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒▒▀▀███▓▄▒▒▀▀███▓▄▒▒▀▀███▓▄▄▒▒▀███▓▄▄▒▒▒███▓
//             ████▒█▓▄▒▒▀▀███▓▄▄▒▒▀████▄▄▒▒▀████▄▄▒▒▀████▄▄▒▒▀▀███▄▄▒▒▀▀███▄▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒▒▀▀███▓▄▄▒▀▀███▓▄▄▒▀▀████▄▄▒▒▀████▄▄▒▒▀████▄▄▒░▀▀▓▄███▀
//              ▀████▓▀███▓▄▄▒░▀███▓▄▄▒░▀▀██▓▄▄▒░▀▀███▄▄▒░▀▀███▄▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░░▀███▓▄▒▒░▀███▓▄▄░░▀███▓▄▄▒░▀▀██▓▄▄▒░▀▀███▄▄▒░▀▀██▓▄████╜
//                ▀██████▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▓██████╙
//                   ▀▀█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▀"

import AsyncJstream from "./AsyncJstream";
import {
    asStandardCollection,
    fisherYatesShuffle,
    groupBy,
    memoizeIterable,
    min,
    nonIteratedCountOrUndefined,
    split,
    toMap,
} from "./privateUtils/data";
import {
    requireInteger,
    requireNonNegative,
    requireSafeInteger,
} from "./privateUtils/errorGuards";
import { identity, resultOf, returns } from "./privateUtils/functional";
import {
    iterableFromIterator,
    iterableFromIteratorGetter,
    lazyIterable,
    range,
} from "./privateUtils/iterable";
import { mkString } from "./privateUtils/strings";
import {
    isArray,
    isIterable,
    isStandardCollection,
} from "./privateUtils/typeGuards";
import {
    AsMap,
    AsMapWithKey,
    AsMapWithValue,
    AsReadonly,
    EntryLikeKey,
    EntryLikeValue,
    ReadonlyStandardCollection,
    StandardCollection,
    ToObject,
    ToObjectWithKey,
    ToObjectWithValue,
} from "./types/collections";
import { General } from "./types/literals";
import { Comparator, Order } from "./types/sorting";
import { BreakSignal } from "./types/symbols";
import { multiCompare, reverseOrder, smartComparator } from "./utils/sorting";
import { breakSignal } from "./utils/symbols";

/**
 * Properties of the {@link Jstream} and its source. Boolean properties are assumed to be "unknown" when undefined, not false.
 */
export type JstreamProperties<_> = Readonly<
    Partial<{
        /** Each call to the source getter produces a new copy of the source. This means that the source can be modified safely, assuming it is a mutable collection like {@link Array}, which is not guarantied. */
        freshSource: boolean;
        /** Calling the source getter is expensive, ie. it's more than an O(1) operation. */
        expensiveSource: boolean;
        /** The source is an instance of either: {@link Array}, {@link Set}, or {@link Map}. */
        standardSource: boolean;
    }>
>;

export default class Jstream<T> implements Iterable<T> {
    private readonly getSource: () => Iterable<T>;
    private readonly properties: JstreamProperties<T>;

    public constructor(
        properties: JstreamProperties<T>,
        getSource: () => Iterable<T>
    ) {
        this.getSource = getSource;
        this.properties = properties;
    }

    /**
     * @returns An iterator over the Jstream.
     */
    public [Symbol.iterator]() {
        return this.getSource()[Symbol.iterator]();
    }

    /**
     * @returns A Jstream over the given source or the result of the given function.
     */
    public static from<T>(
        source: Iterable<T> | Iterator<T> | (() => Iterable<T> | Iterator<T>)
    ): Jstream<T> {
        if (source instanceof Function) {
            return new Jstream({ expensiveSource: true }, () => {
                const subSource = source();

                if (isIterable(subSource)) {
                    return subSource;
                } else {
                    return iterableFromIterator(subSource);
                }
            });
        } else if (source instanceof Jstream) {
            return source;
        } else if (
            source instanceof Array ||
            source instanceof Set ||
            source instanceof Map
        ) {
            return new Jstream(
                { expensiveSource: false, standardSource: true },
                () => source
            );
        } else if (isIterable(source)) {
            return new Jstream({ expensiveSource: false }, () => source);
        } else {
            const iterable = iterableFromIterator(source);
            return new Jstream({ expensiveSource: false }, () => iterable);
        }
    }

    /**
     * @returns A Jstream over the given items.
     */
    public static of<T>(...items: readonly T[]): Jstream<T> {
        return new Jstream({}, () => items);
    }

    /**
     * @returns An empty Jstream of the given type.
     */
    public static empty<T>(): Jstream<T> {
        return Jstream.of<T>();
    }

    /**
     * @returns A Jstream over the entries of the given object.
     */
    public static fromObject<K extends keyof any, V>(
        object: Record<K, V>,
        {
            includeStringKeys = true,
            includeSymbolKeys = true,
        }: {
            /** Whether to include fields index by symbols. Defaults to true. */
            includeSymbolKeys?: boolean;
            /** Whether to include fields index by strings. Defaults to true. */
            includeStringKeys?: boolean;
        }
    ): Jstream<[K & (string | symbol), V]> {
        if (includeStringKeys && includeSymbolKeys) {
            return new Jstream({ expensiveSource: true }, () =>
                Object.getOwnPropertySymbols(object)
            )
                .concat(lazyIterable(() => Object.getOwnPropertyNames(object)))
                .map(key => [
                    key as K & (string | symbol),
                    (object as any)[key] as V,
                ]);
        } else if (includeStringKeys) {
            return new Jstream({ expensiveSource: true }, () =>
                Object.getOwnPropertyNames(object).map(name => [
                    name as K & (string | symbol),
                    (object as any)[name] as V,
                ])
            );
        } else if (includeSymbolKeys) {
            return new Jstream({ expensiveSource: true }, () =>
                Object.getOwnPropertySymbols(object).map(symbol => [
                    symbol as K & (string | symbol),
                    (object as any)[symbol] as V,
                ])
            );
        } else {
            return Jstream.empty();
        }
    }

    /**
     * @returns A Jstream over a range of integers from start to end, incremented by step.
     */
    public static range(
        start: bigint,
        end: bigint,
        step: bigint
    ): Jstream<bigint>;
    /**
     * @returns A Jstream over a range of integers from start to end, incremented by 1 or -1 if end is less than start.
     */
    public static range(start: bigint, end: bigint): Jstream<bigint>;
    /**
     * @returns A Jstream over a range of integers from 0 to end, incremented by 1.
     */
    public static range(end: bigint): Jstream<bigint>;

    /**
     * @returns A Jstream over a range of integers from start to end, incremented by step.
     */
    public static range(
        start: number | bigint,
        end: number | bigint,
        step: number | bigint
    ): Jstream<number>;
    /**
     * @returns A Jstream over a range of integers from start to end, incremented by 1 or -1 if end is less than start.
     */
    public static range(
        start: number | bigint,
        end: number | bigint
    ): Jstream<number>;
    /**
     * @returns A Jstream over a range of integers from 0 to end, incremented by 1.
     */
    public static range(end: number | bigint): Jstream<number>;

    public static range(
        _startOrEnd: number | bigint,
        _end?: number | bigint,
        _step?: number | bigint
    ): Jstream<number> | Jstream<bigint> {
        if (_end === undefined) {
            const end = _startOrEnd;
            return Jstream.from(range(end));
        } else if (_step === undefined) {
            const start = _startOrEnd;
            const end = _end;
            return Jstream.from(range(start, end));
        } else {
            const start = _startOrEnd;
            const end = _end;
            const step = _step;
            return Jstream.from(range(start, end, step));
        }
    }

    /**
     * Calls the action on each item in the stream in order. Stops if the action returns {@link breakSignal}.
     * @param action The action.
     */
    public forEach(
        action: (item: T, index: number) => void | BreakSignal
    ): void {
        let i = 0;
        for (const item of this) {
            const signal = action(item, i);
            if (signal === breakSignal) break;
            i++;
        }
    }

    // =====================
    // basic transformations
    // =====================
    /**
     * Maps each item in the stream to a new item using the given mapping function.
     */
    public map<R>(mapping: (item: T, index: number) => R): Jstream<R> {
        const self = this;

        return new Jstream({}, function* () {
            let i = 0;
            for (const item of self) {
                yield mapping(item, i);
                i++;
            }
        });
    }

    /**
     * Maps each item in the stream to a tuple containing the item's index and then the item in that order.
     */
    public withIndex(): Jstream<[number, T]> {
        return this.map((item, index) => [index, item]);
    }

    /**
     * Filters the stream to only the items that make the given condition checking function return true.
     */
    public filter<R extends T = T>(
        condition: (item: T, index: number) => boolean
    ): Jstream<R> {
        const self = this;

        return new Jstream({}, function* () {
            let i = 0;
            for (const item of self) {
                if (condition(item, i)) yield item as R;
                i++;
            }
        });
    }

    /**
     * Appends the items to the end of the stream.
     */
    public concat<O>(items: Iterable<O>): Jstream<T | O> {
        const self = this;
        return new Jstream({}, function* () {
            yield* self;
            yield* items;
        });
    }

    /**
     * Appends the items to the start of the stream.
     */
    public preConcat<O>(items: Iterable<O>): Jstream<O | T> {
        const self = this;
        return new Jstream({}, function* () {
            yield* items;
            yield* self;
        });
    }

    /**
     * Appends the item to the end of the stream.
     */
    public append<O>(item: O): Jstream<T | O> {
        return this.concat([item]);
    }

    /**
     * Appends the item to the start of the stream.
     */
    public prepend<O>(item: O): Jstream<O | T> {
        return this.preConcat([item]);
    }

    /** Sorts the stream using the given comparator in ascending order. */
    public sortBy(comparator: Comparator<T>): SortedJstream<T>;

    /** Sorts the stream by the result of the given mapping function using {@link smartComparator} in ascending order. */
    public sortBy(keySelector: (item: T) => any): SortedJstream<T>;

    public sortBy(order: Order<T>): SortedJstream<T> {
        return new SortedJstream([order], this.properties, this.getSource);
    }

    /** Sorts the stream using the given comparator in descending order. */
    public sortByDescending(comparator: Comparator<T>): SortedJstream<T>;

    /** Sorts the stream by the result of the given mapping function using {@link smartComparator} in descending order. */
    public sortByDescending(keySelector: (item: T) => any): SortedJstream<T>;

    public sortByDescending(order: Order<T>): SortedJstream<T> {
        return new SortedJstream(
            [reverseOrder(order)],
            this.properties,
            this.getSource
        );
    }

    /**
     * Reverses the order of the stream.
     */
    public reverse(): Jstream<T> {
        return new Jstream({ expensiveSource: true, freshSource: true }, () => {
            const source = this.getSource();

            if (isArray(source)) {
                return iterableFromIteratorGetter(function* () {
                    for (let i = source.length - 1; i >= 0; i--) {
                        yield source[i]!;
                    }
                });
            } else {
                const array = [...source];
                array.reverse();
                return array;
            }
        });
    }

    /**
     * Repeats the stream the given number of times.
     * @param times How many repeats to make. 1 does nothing. 0 returns an empty stream. Negative numbers reverse the stream before repeating it. Must be an integer.
     */
    public repeat(times: number | bigint): Jstream<T> {
        requireInteger(times);

        if (times === 0) return Jstream.empty();
        if (times < 0) return this.reverse().repeat(-times);

        const self = this;

        return new Jstream({}, function* () {
            const memoized = memoizeIterable(self);
            for (let i = 0n; i < times; i++) {
                for (const item of memoized) {
                    yield item;
                }
            }
        });
    }

    /**
     * Filters undefined out of the stream.
     */
    public defined(): Jstream<T & ({} | null)> {
        return this.filter(item => item !== undefined);
    }

    /**
     * Filters null out of the stream.
     */
    public nonNull(): Jstream<T & ({} | undefined)> {
        return this.filter(item => item !== null);
    }

    /** Equivalent to {@link Array.copyWithin}. */
    public copyWithin(
        target: number | bigint,
        start: number | bigint,
        end?: number | bigint
    ): Jstream<T> {
        return new Jstream(
            { expensiveSource: true, freshSource: true, standardSource: true },
            () =>
                this.toArray().copyWithin(
                    Number(target),
                    Number(start),
                    Number(end)
                )
        );
    }

    /** Shuffles the contents of the stream. */
    public shuffle(): Jstream<T> {
        return new Jstream(
            { expensiveSource: true, freshSource: true, standardSource: true },
            () => {
                const array = this.toArray();
                fisherYatesShuffle(array);
                return array;
            }
        );
    }

    /**
     * Skips the given number of items in the stream.
     * @param count How many items to skip. Must be a non negative integer.
     */
    public skip(count: number | bigint): Jstream<T> {
        requireNonNegative(requireInteger(count));

        const self = this;
        return new Jstream({}, function* () {
            const iterator = self[Symbol.iterator]();

            for (let i = 0n; i < count; i++) {
                if (iterator.next().done) return;
            }

            let next: IteratorResult<T>;

            while (!(next = iterator.next()).done) {
                yield next.value;
            }
        });
    }

    /** Skips the given number of items at the end of the stream. */
    public skipLast(count: number | bigint): Jstream<T> {
        requireNonNegative(requireSafeInteger(count));

        if (count === 0 || count === 0n) return this;
        if (typeof count === "bigint") {
            return this.skipLast(Number(count));
        }

        return new Jstream(
            {
                expensiveSource: true,
                freshSource: true,
            },
            () => {
                const source = this;
                if (isArray(source)) {
                    if (this.properties.freshSource) {
                        source.length -= Math.min(count, source.length);
                        return source;
                    } else {
                        return iterableFromIteratorGetter(function* () {
                            for (let i = 0; i < source.length - count; i++) {
                                yield source[i] as T;
                            }
                        });
                    }
                } else {
                    const array = [...source];
                    array.length -= Math.min(count, array.length);
                    return array;
                }
            }
        );
    }

    /**
     * Skips items from stream until one causes the condition to return false.
     * Takes the rest including the item that caused the condition to return false.
     */
    public skipWhile(
        condition: (item: T, index: number) => boolean
    ): Jstream<T> {
        const self = this;
        return new Jstream({}, function* () {
            const iterator = self[Symbol.iterator]();
            let index = 0;
            let next: IteratorResult<T> = iterator.next();
            do {
                if (!condition(next.value, index)) {
                    break;
                }
                index++;
            } while (!(next = iterator.next()).done);

            do {
                yield next.value;
            } while (!(next = iterator.next()).done);
        });
    }

    /** Takes the given number of items from the stream and skips the rest. */
    public take(count: number | bigint): Jstream<T> {
        requireNonNegative(requireInteger(count));
        const self = this;
        return new Jstream({}, function* () {
            const iterator = self[Symbol.iterator]();

            for (let i = 0n; i < count; i++) {
                const next = iterator.next();
                if (next.done) return;
                yield next.value;
            }
        });
    }

    /** Takes the given number of items from the end of the stream and skips the rest. */
    public takeLast(count: number | bigint): Jstream<T> {
        requireNonNegative(requireSafeInteger(count));
        if (count === 0 || count === 0n) return this;
        if (typeof count === "bigint") return this.takeLast(Number(count));

        const self = this;
        return new Jstream({}, function* () {
            const array = self.asArray();
            if (count >= array.length) return;
            for (let i = array.length - count; i < array.length; i++) {
                yield array[i] as T;
            }
        });
    }

    /** Takes items from stream until one causes the condition to return false. The rest are skipped including the item that caused the condition to return false. */
    public takeWhile(
        condition: (item: T, index: number) => boolean
    ): Jstream<T> {
        const self = this;
        return new Jstream({}, function* () {
            let index = 0;
            for (const item of self) {
                if (condition(item, index)) {
                    yield item;
                } else {
                    break;
                }
                index++;
            }
        });
    }

    /**
     * Groups the items in the stream by the given keySelector.
     */
    public groupBy<K>(
        keySelector: (item: T, index: number) => K
    ): Jstream<[K, T[]]>;

    /**
     * Groups the items in the stream by the given keySelector.
     *
     * @param groupSelector Mapping applied to each group.
     */
    public groupBy<K, G>(
        keySelector: (item: T, index: number) => K,
        groupSelector: (group: T[], key: K) => G
    ): Jstream<[K, G]>;

    public groupBy<K, G>(
        keySelector: (item: T, index: number) => K,
        groupSelector?: (group: T[], key: K) => G
    ): Jstream<[K, T[] | G]> {
        return new Jstream(
            { expensiveSource: true, freshSource: true, standardSource: true },
            () => {
                const groups = new Map<K, any>();

                let index = 0;
                for (const item of this) {
                    const key = keySelector(item, index);

                    const group = groups.get(key);
                    if (group === undefined) {
                        groups.set(key, [item]);
                    } else {
                        group.push(item);
                    }

                    index++;
                }

                if (groupSelector !== undefined) {
                    for (const entry of groups) {
                        const group = groupSelector(entry[1], entry[0]);
                        groups.set(entry[0], group);
                    }
                }

                return groups;
            }
        );
    }

    /**
     * Replaces the contents of the stream with the given alternative if the stream is empty.
     */
    public ifEmpty<R>(alternative: Iterable<R>): Jstream<T> | Jstream<R>;

    /**
     * Replaces the contents of the stream with the result of the given function if the stream is empty.
     */
    public ifEmpty<R>(alternative: () => Iterable<R>): Jstream<T> | Jstream<R>;

    public ifEmpty<R>(
        alternative: Iterable<R> | (() => Iterable<R>)
    ): Jstream<T> | Jstream<R> {
        return new Jstream<T | R>(
            {
                expensiveSource: true,
            },
            () => {
                const source = this.getSource();
                const count = nonIteratedCountOrUndefined(source);

                if (count !== undefined) {
                    if (count === 0) {
                        return resultOf(alternative);
                    } else {
                        return source;
                    }
                }

                return (function* () {
                    const iterator = source[Symbol.iterator]();
                    let next = iterator.next();
                    if (next.done) {
                        yield* resultOf(alternative);
                        return;
                    }

                    do {
                        yield next.value;
                    } while (!(next = iterator.next()).done);
                })();
            }
        ) as Jstream<T> | Jstream<R>;
    }

    /**
     * Flattens the stream.
     */
    public flat(): Jstream<T extends Iterable<infer SubT> ? SubT : T> {
        const self = this;
        return new Jstream({}, function* () {
            for (const item of self) {
                if (isIterable(item)) {
                    yield* item as any;
                } else {
                    yield item;
                }
            }
        });
    }

    /**
     * Splits the collection on the deliminator.
     * Equivalent to {@link String.split} except that regular expressions aren't supported.
     */
    public split<O>(deliminator: Iterable<O>, equalityChecker?: (t: T, o: O) => boolean): Jstream<T[]>{
        return new Jstream({}, () => split(this, deliminator, equalityChecker));
    }

    /**
     * Iterates the {@link Jstream}, caching the result. Returns a {@link Jstream} over that cached result.
     */
    public collapse(): Jstream<T> {
        return Jstream.from([...this]);
    }

    // =======================
    // reduction to non-stream
    // =======================
    /**
     * Reduces the stream to a single value using the given reducer function.
     * This function is first called on the first two items in the stream like this: reducer(first, second, 1).
     * The index given corresponds to the second item given to the function.
     * Next the result of that call and the third item are given to the function: reducer(result, third, 2).
     * This continues until the final item: reducer(result, final, final index).
     * The result of that call is returned.
     *
     * If the stream only contains 1 item, that item is returned.
     *
     * If the stream contains no items, an Error is thrown.
     */
    public reduce(
        reducer: (result: General<T>, item: T, index: number) => General<T>
    ): General<T>;

    /**
     * Reduces the stream to a single value in the same way as {@link Jstream.reduce}.
     * The difference is that the given finalize function is called on the result.
     * The result of this function is returned instead of the original result.
     * @param Applied to the result and the number of items in the stream. The result of this is what gets returned.
     */
    public reduce<F>(
        reducer: (result: General<T>, item: T, index: number) => General<T>,
        finalize: (result: General<T>, count: number) => F
    ): F;

    public reduce<F = General<T>>(
        reducer: (result: General<T>, item: T, index: number) => General<T>,
        finalize?: (result: General<T>, count: number) => F
    ): F {
        const iterator = this[Symbol.iterator]();
        let next = iterator.next();

        if (next.done) {
            throw new Error("cannot reduce empty iterable. no initial value");
        }

        let result: General<T> = next.value as General<T>;

        let i = 1;
        while (!(next = iterator.next()).done) {
            result = reducer(result, next.value, i);

            i++;
        }

        if (finalize !== undefined) {
            return finalize(result, i);
        } else {
            return result as F;
        }
    }

    /**
     * Reduces the stream in the same way as {@link Jstream.reduce}.
     * The difference is the given initialValue is used in place of the first value in the fist call to the given reducer function:
     * reducer(initialValue, first, 0). The index given corresponding to the item given to the function.
     * Unlike {@link Jstream.reduce}, an Error isn't thrown in the case of an empty stream. The initial value is returned instead.
     */
    public fold<R>(
        initialValue: R,
        reducer: (result: R, item: T, index: number) => R
    ): R;

    /**
     * Reduces the stream in the same way as {@link Jstream.fold}.
     * The difference is that the given finalize function is called on the result.
     * The result of this function is returned instead of the original result.
     * @param Applied to the result and the number of items in the stream not including the initial value. The result of this is what gets returned.
     */
    public fold<R, F>(
        initialValue: R,
        reducer: (result: R, item: T, index: number) => R,
        finalize: (result: R, count: number) => F
    ): F;

    public fold<R, F = R>(
        initialValue: R,
        reducer: (result: R, item: T, index: number) => R,
        finalize?: (result: R, count: number) => F
    ): F | R {
        let result = initialValue;

        let i = 0;
        for (const item of this) {
            result = reducer(result, item, i);
            i++;
        }

        if (finalize !== undefined) {
            return finalize(result, i);
        } else {
            return result;
        }
    }

    /**
     * Counts the number of items in the stream. This will usually require iterating the stream.
     * To avoid this, consider using {@link Jstream.nonIteratedCountOrUndefined}.
     *
     * @returns The number of items in the stream.
     */
    public count(): number {
        const source = this.getSource();
        const nonIteratedCount = nonIteratedCountOrUndefined(source);

        if (nonIteratedCount !== undefined) {
            return nonIteratedCount;
        } else {
            let count = 0;
            for (const _ of source) count++;
            return count;
        }
    }

    /**
     * @returns the number of items in the stream if this can be determined without iterating it. Returns undefined otherwise.
     */
    public nonIteratedCountOrUndefined(): number | undefined {
        if (this.properties.expensiveSource) return undefined;
        const source = this.getSource();
        return nonIteratedCountOrUndefined(source);
    }

    /**
     * Copies the stream into an Array.
     * @returns The Array. As this is a copy of the stream, it is safe to modify.
     */
    public toArray(): T[] {
        const source = this.getSource();
        if (this.properties.freshSource && Array.isArray(source)) {
            return source;
        } else {
            return [...source];
        }
    }

    /**
     * Creates an Array view of the stream. This will usually entail copying the stream into an Array like {@link Jstream.toArray} but not always so the result is not safe to modify.
     * @returns A readonly array containing the contents of the stream.
     */
    public asArray(): readonly T[] {
        const source = this.getSource();
        if (Array.isArray(source)) {
            return source;
        } else {
            return [...source];
        }
    }

    /**
     * Copies the stream into a {@link Set}.
     * @returns The {@link Set}. As this is a copy of the stream, it is safe to modify.
     */
    public toSet(): Set<T> {
        const source = this.getSource();
        if (this.properties.freshSource && source instanceof Set) {
            return source;
        } else {
            return new Set(source);
        }
    }

    /**
     * Creates a {@link Set} view of the stream. This will usually entail copying the stream into a Set like {@link Jstream.toSet} but not always so the result is not safe to modify.
     * @returns A readonly {@link Set} containing the contents of the stream.
     */
    public asSet(): ReadonlySet<T> {
        const source = this.getSource();
        if (source instanceof Set) {
            return source;
        } else {
            return new Set(source);
        }
    }

    /**
     * Copies the stream into a {@link Map}.
     * @returns The {@link Map}. As this is a copy of the stream, it is safe to modify.
     */
    public toMap(): AsMap<Iterable<T>>;

    /**
     * Copies the stream into a {@link Map}.
     * @returns The {@link Map}. As this is a copy of the stream, it is safe to modify.
     *
     * @param keySelector Not used.
     * @param valueSelector Maps each item in the stream to its value in the {@link Map}.
     */
    public toMap<V>(
        keySelector: undefined,
        valueSelector: (item: T, index: number) => V
    ): AsMapWithValue<Iterable<T>, V>;

    /**
     * Copies the stream into a {@link Map}.
     * @returns The {@link Map}. As this is a copy of the stream, it is safe to modify.
     *
     * @param keySelector Maps each item in the stream to its key in the {@link Map}.
     */
    public toMap<K>(
        keySelector: (item: T, index: number) => K
    ): AsMapWithKey<Iterable<T>, K>;

    /**
     * Copies the stream into a {@link Map}.
     * @returns The {@link Map}. As this is a copy of the stream, it is safe to modify.
     *
     * @param keySelector Maps each item in the stream to its key in the {@link Map}.
     * @param valueSelector Maps each item in the stream to its value in the {@link Map}.
     */
    public toMap<K, V>(
        keySelector: (item: T, index: number) => K,
        valueSelector: (item: T, index: number) => V
    ): Map<K, V>;

    /**
     * Copies the stream into a {@link Map}.
     * @returns The {@link Map}. As this is a copy of the stream, it is safe to modify.
     *
     * @param keySelector If provided: maps each item in the stream to its key in the {@link Map}.
     * @param valueSelector If provided: maps each item in the stream to its value in the {@link Map}.
     */
    public toMap<
        K = T extends EntryLikeKey<infer K> ? K : unknown,
        V = T extends EntryLikeValue<infer V> ? V : unknown
    >(
        keySelector?: (item: T, index: number) => K,
        valueSelector?: (item: T, index: number) => V
    ): Map<K, V>;

    public toMap(
        keySelector?: (item: any, index: number) => any,
        valueSelector?: (item: any, index: number) => any
    ): Map<any, any> {
        return toMap(this, keySelector, valueSelector);
    }

    /**
     * Creates a {@link Map} view of the stream. This will usually entail copying the stream into a Map like {@link Jstream.toSet} but not always so the result is not safe to modify.
     * @returns A readonly {@link Map} containing the contents of the stream.
     */
    public asMap(): AsReadonly<AsMap<Iterable<T>>> {
        const source = this.getSource();
        if (source instanceof Map) {
            return source as any;
        } else {
            return toMap(source) as any;
        }
    }

    /**
     * Copies the stream into an object.
     * @returns The object. As this is a copy of the stream, it is safe to modify.
     */
    public toObject(): ToObject<Iterable<T>>;

    /**
     * Copies the stream into an object.
     * @returns The object. As this is a copy of the stream, it is safe to modify.
     *
     * @param keySelector Not used.
     * @param valueSelector Maps each item in the stream to its value in the object.
     */
    public toObject<V>(
        keySelector: undefined,
        valueSelector: (item: T, index: number) => V
    ): ToObjectWithValue<Iterable<T>, V>;

    /**
     * Copies the stream into an object.
     * @returns The object. As this is a copy of the stream, it is safe to modify.
     *
     * @param keySelector Maps each item in the stream to its key in the object.
     */
    public toObject<K extends keyof any>(
        keySelector: (item: T, index: number) => K
    ): ToObjectWithKey<Iterable<T>, K>;

    /**
     * Copies the stream into an object.
     * @returns The object. As this is a copy of the stream, it is safe to modify.
     *
     * @param keySelector Maps each item in the stream to its key in the object.
     * @param valueSelector Maps each item in the stream to its value in the object.
     */
    public toObject<K extends keyof any, V>(
        keySelector: (item: T, index: number) => K,
        valueSelector: (item: T, index: number) => V
    ): Record<K, V>;

    /**
     * Copies the stream into an object.
     * @returns The object. As this is a copy of the stream, it is safe to modify.
     *
     * @param keySelector If provided: maps each item in the stream to its key in the object.
     * @param valueSelector If provided: maps each item in the stream to its value in the object.
     */
    public toObject<K extends keyof any, V>(
        keySelector?: (item: T, index: number) => K,
        valueSelector?: (item: T, index: number) => V
    ): Record<K, V>;

    public toObject(
        keySelector: (item: any, index: number) => keyof any = i => i?.[0],
        valueSelector: (item: any, index: number) => any = i => i?.[1]
    ): Record<keyof any, any> {
        const object: Record<keyof any, any> = {};

        let i = 0;
        for (const item of this) {
            const key = keySelector(item, i);
            const value = valueSelector(item, i);

            object[key] = value;

            i++;
        }

        return object;
    }

    /**
     * Copies the stream into one of javascript's standard collections (like {@link Array}, {@link Set}, or {@link Map}).
     * Usually, this will be an array, but that is not guarantied.
     */
    public toStandardCollection(): StandardCollection<T> {
        const source = this.getSource();
        if (this.properties.freshSource && isStandardCollection(source)) {
            return source;
        } else {
            return [...source];
        }
    }

    /**
     * Creates a view of the stream as one of javascript's standard collections (like {@link Array}, {@link Set}, or {@link Map}).
     * This will usually entail copying the stream like {@link Jstream.toStandardCollection} but not always so the result is not safe to modify.
     */
    public asStandardCollection(): ReadonlyStandardCollection<T> {
        const source = this.getSource();
        if (isStandardCollection(source)) {
            return source;
        } else {
            return [...source];
        }
    }

    /**
     * Finds the first item in the stream that makes the given condition function return true.
     */
    public find(condition: (item: T, index: number) => boolean): T | undefined;

    /**
     * Finds the first item in the stream that makes the given condition function return true.
     * @param alternative If no item is found, this will be returned or the result of this will be returned if this is a function.
     */
    public find<A>(
        condition: (item: T, index: number) => boolean,
        alternative: A | (() => A)
    ): T | A;

    public find(
        condition: (item: T, index: number) => boolean,
        alternative?: any
    ): any {
        let i = 0;
        for (const item of this) {
            if (condition(item, i)) return item;
            i++;
        }
        return resultOf(alternative);
    }
    /**
     * Finds the last item in the stream that makes the given condition function return true.
     */
    public findLast(
        condition: (item: T, index: number) => boolean
    ): T | undefined;

    /**
     * Finds the last item in the stream that makes the given condition function return true.
     * @param alternative If no item is found, this will be returned or the result of this will be returned if this is a function.
     */
    public findLast<A>(
        condition: (item: T, index: number) => boolean,
        alternative: A | (() => A)
    ): T | A;

    public findLast(
        condition: (item: T, index: number) => boolean,
        alternative?: any
    ): any {
        let i = 0;
        let result = resultOf(alternative);
        for (const item of this) {
            if (condition(item, i)) result = item;
            i++;
        }
        return result;
    }

    /**
     * Finds the smallest item in the stream using {@link smartComparator}.
     * @param count How many item to find (unless the stream has less items than that.)
     */
    public min(count: number | bigint): T[];
    /**
     * Finds the smallest item in the stream using the given comparator.
     * @param count How many item to find (unless the stream has less items than that.)
     */
    public min(count: number | bigint, comparator: Comparator<T>): T[];
    /**
     * Finds the smallest item in the stream using the mapping from the given key selector and {@link smartComparator}.
     * @param count How many item to find (unless the stream has less items than that.)
     */
    public min(count: number | bigint, keySelector: (item: T) => any): T[];
    public min(count: number | bigint, order: Order<T> = smartComparator): T[] {
        return min(this, count, order);
    }

    /**
     * Finds the largest item in the stream using {@link smartComparator}.
     * @param count How many item to find (unless the stream has less items than that.)
     */
    public max(count: number | bigint): T[];
    /**
     * Finds the largest item in the stream using the given comparator.
     * @param count How many item to find (unless the stream has less items than that.)
     */
    public max(count: number | bigint, comparator: Comparator<T>): T[];
    /**
     * Finds the largest item in the stream using the mapping from the given key selector and {@link smartComparator}.
     * @param count How many item to find (unless the stream has less items than that.)
     */
    public max(count: number | bigint, keySelector: (item: T) => any): T[];
    public max(count: number | bigint, order: Order<T> = smartComparator): T[] {
        return min(this, count, reverseOrder(order));
    }

    /**
     * @returns Whether at least one item in the stream causes the given condition function to return true.
     */
    public some(
        condition: (item: T, index: number) => boolean = returns(true)
    ): boolean {
        let i = 0;
        for (const item of this) {
            if (condition(item, i)) return true;
        }
        return false;
    }

    /**
     * The inverse of {@link Jstream.some}.
     * @returns Whether none item in the stream causes the given condition function to return true.
     */
    public none(
        condition: (item: T, index: number) => boolean = returns(true)
    ): boolean {
        return !this.some(condition);
    }

    /**
     * @returns Whether every item in the stream causes the given condition function to return true.
     */
    public every(condition: (item: T, index: number) => boolean): boolean {
        let i = 0;
        for (const item of this) {
            if (!condition(item, i)) return false;
        }
        return true;
    }

    /**
     * @returns The stream as an {@link AsyncJstream}.
     */
    public toAsyncJstream(): AsyncJstream<T> {
        return new AsyncJstream(this.getSource, this.properties);
    }

    /**
     * @returns The string values of each item in the stream concatenated together.
     */
    public mkString(): string;
    /**
     * @returns The string values of each item in the stream concatenated together with the string value of the given separator between them.
     */
    public mkString(separator: any): string;
    /**
     * @returns The string values of each item in the stream concatenated together with the string value of the given separator between them.
     * @param start Concatenated onto the start of the resulting string.
     * @param end If provided: concatenated onto the end of the resulting string.
     */
    public mkString(start: any, separator: any, end?: any): string;
    public mkString(
        startOrSeparator?: any,
        separator?: any,
        end?: any
    ): string {
        if (arguments.length === 1) {
            const separator = startOrSeparator;
            return mkString(this.getSource(), separator);
        } else {
            const start = startOrSeparator;
            return mkString(this.getSource(), start, separator, end);
        }
    }

    /**
     * @returns The string values of each item in the stream concatenated together.
     */
    public toString(): string {
        return this.mkString();
    }

    /**
     * @returns The stream as an array.
     */
    public toJSON(): readonly T[] {
        return this.asArray();
    }

    // ===================
    // big and complicated
    // ===================
    // TODO documentation

    public join<O, K, R>(
        other: Iterable<O>,
        keySelector: (item: T, index: number) => K,
        otherKeySelector: (item: O, index: number) => K,
        resultSelector: (item: T, otherItem: O) => R
    ): Jstream<R>;

    public join<O, K, R>(
        other: Iterable<O>,
        resultSelector: (item: T, otherItem: O) => R,
        comparison: (item: T, otherItem: O) => boolean
    ): Jstream<R>;

    public join<O, K, R>(
        other: Iterable<O>,
        keySelectorOrResultSelector:
            | ((item: T, index: number) => K)
            | ((item: T, otherItem: O) => R),
        otherKeySelectorOrComparison:
            | ((item: O, index: number) => K)
            | ((item: T, otherItem: O) => boolean),
        resultSelector?: (item: T, otherItem: O) => R
    ): Jstream<R> {
        const self = this;
        if (resultSelector !== undefined) {
            const keySelector = keySelectorOrResultSelector as (
                item: T,
                index: number
            ) => K;
            const otherKeySelector = otherKeySelectorOrComparison as (
                item: O,
                index: number
            ) => K;
            return new Jstream({ expensiveSource: true }, function* () {
                const otherIndexed = toMap(other, otherKeySelector, identity);

                let i = 0;
                for (const item of self) {
                    const key = keySelector(item, i);
                    const otherItem = otherIndexed.get(key);
                    if (otherItem !== undefined) {
                        yield resultSelector(item, otherItem);
                    }
                    i++;
                }
            });
        } else {
            const resultSelector = keySelectorOrResultSelector as (
                item: T,
                otherItem: O
            ) => R;
            const comparison = otherKeySelectorOrComparison as (
                item: T,
                otherItem: O
            ) => boolean;

            return new Jstream({ expensiveSource: true }, function* () {
                const otherCached = asStandardCollection(other) as Iterable<O>;

                for (const item of self) {
                    for (const otherItem of otherCached) {
                        if (comparison(item, otherItem)) {
                            yield resultSelector(item, otherItem);
                        }
                    }
                }
            });
        }
    }

    public leftJoin<I, K, R>(
        inner: Iterable<I>,
        keySelector: (item: T, index: number) => K,
        innerKeySelector: (item: I, index: number) => K,
        resultSelector: (item: T, innerItem: I | undefined) => R
    ): Jstream<R>;

    public leftJoin<I, K, R>(
        inner: Iterable<I>,
        resultSelector: (item: T, innerItem: I | undefined) => R,
        comparison: (item: T, innerItem: I) => boolean
    ): Jstream<R>;

    public leftJoin<I, K, R>(
        inner: Iterable<I>,
        keySelectorOrResultSelector:
            | ((item: T, index: number) => K)
            | ((item: T, innerItem: I | undefined) => R),
        innerKeySelectorOrComparison:
            | ((item: I, index: number) => K)
            | ((item: T, innerItem: I) => boolean),
        resultSelector?: (item: T, innerItem: I | undefined) => R
    ): Jstream<R> {
        const self = this;
        if (resultSelector !== undefined) {
            const keySelector = keySelectorOrResultSelector as (
                item: T,
                index: number
            ) => K;
            const innerKeySelector = innerKeySelectorOrComparison as (
                item: I,
                index: number
            ) => K;
            return new Jstream({ expensiveSource: true }, function* () {
                const innerIndexed = toMap(inner, innerKeySelector, identity);

                let i = 0;
                for (const item of self) {
                    const key = keySelector(item, i);
                    const innerItem = innerIndexed.get(key);
                    yield resultSelector(item, innerItem);
                    i++;
                }
            });
        } else {
            const resultSelector = keySelectorOrResultSelector as (
                item: T,
                innerItem: I | undefined
            ) => R;
            const comparison = innerKeySelectorOrComparison as (
                item: T,
                innerItem: I
            ) => boolean;

            return new Jstream({ expensiveSource: true }, function* () {
                const innerCached = asStandardCollection(inner) as Iterable<I>;

                for (const item of self) {
                    let innerMatch: I | undefined = undefined;
                    for (const innerItem of innerCached) {
                        if (comparison(item, innerItem)) {
                            innerMatch = innerItem;
                            break;
                        }
                    }
                    yield resultSelector(item, innerMatch);
                }
            });
        }
    }

    public groupJoin<I, K, R>(
        inner: Iterable<I>,
        keySelector: (item: T, index: number) => K,
        innerKeySelector: (item: I, index: number) => K,
        resultSelector: (item: T, innerItem: I[]) => R
    ): Jstream<R>;

    public groupJoin<I, K, R>(
        inner: Iterable<I>,
        resultSelector: (item: T, innerItem: I[]) => R,
        comparison: (item: T, innerItem: I) => boolean
    ): Jstream<R>;

    public groupJoin<I, K, R>(
        inner: Iterable<I>,
        keySelectorOrResultSelector:
            | ((item: T, index: number) => K)
            | ((item: T, innerItem: I[]) => R),
        innerKeySelectorOrComparison:
            | ((item: I, index: number) => K)
            | ((item: T, innerItem: I) => boolean),
        resultSelector?: (item: T, innerItem: I[]) => R
    ): Jstream<R> {
        const self = this;
        if (resultSelector !== undefined) {
            const keySelector = keySelectorOrResultSelector as (
                item: T,
                index: number
            ) => K;
            const innerKeySelector = innerKeySelectorOrComparison as (
                item: I,
                index: number
            ) => K;

            return new Jstream({ expensiveSource: true }, function* () {
                const innerGrouped = groupBy(inner, innerKeySelector);

                let i = 0;
                for (const item of self) {
                    const key = keySelector(item, i);
                    const innerGroup = innerGrouped.get(key) ?? [];
                    yield resultSelector(item, innerGroup);
                    i++;
                }
            });
        } else {
            const resultSelector = keySelectorOrResultSelector as (
                item: T,
                innerItem: I[]
            ) => R;
            const comparison = innerKeySelectorOrComparison as (
                item: T,
                innerItem: I
            ) => boolean;

            return new Jstream({ expensiveSource: true }, function* () {
                const innerCached = asStandardCollection(inner) as Iterable<I>;

                for (const item of self) {
                    let innerGroup: I[] = [];
                    for (const innerItem of innerCached) {
                        if (comparison(item, innerItem)) {
                            innerGroup.push(innerItem);
                        }
                    }
                    yield resultSelector(item, innerGroup);
                }
            });
        }
    }
}

export class SortedJstream<T> extends Jstream<T> {
    /** the order to sort the items in */
    private readonly order: readonly Order<T>[];
    /** the order to sort the items in put into a comparator */
    private readonly comparator: Comparator<T>;
    /** the original getSource function */
    private readonly getUnsortedSource: () => Iterable<T>;
    /** the properties of the original stream */
    private readonly unsortedProperties: JstreamProperties<T>;

    public constructor(
        order: readonly Order<T>[],
        properties: JstreamProperties<T> = {},
        getSource: () => Iterable<T>
    ) {
        super(
            { standardSource: true, expensiveSource: true, freshSource: true },
            () => {
                const source = getSource();
                let arr: T[];
                if (properties.freshSource && isArray(source)) {
                    arr = source;
                } else {
                    arr = [...source];
                }
                arr.sort(this.comparator);
                return arr;
            }
        );

        this.getUnsortedSource = getSource;
        this.unsortedProperties = properties;
        this.order = order;
        this.comparator = multiCompare(order);
    }

    /** Sorts the stream by the given comparator in ascending order after all previous sorts. */
    public thenBy(comparator: Comparator<T>): SortedJstream<T>;
    /** Sorts the stream by the result of the given mapping function using {@link smartComparator} in ascending order after all previous sorts. */
    public thenBy(keySelector: (item: T) => any): SortedJstream<T>;
    public thenBy(order: Order<T>): SortedJstream<T> {
        return new SortedJstream<T>(
            [...this.order, order],
            this.unsortedProperties,
            this.getUnsortedSource
        );
    }

    /** Sorts the stream by the given comparator in descending order after all previous sorts. */
    public thenByDescending(comparator: Comparator<T>): SortedJstream<T>;
    /** Sorts the stream by the result of the given mapping function using {@link smartComparator} in descending order after all previous sorts. */
    public thenByDescending(keySelector: (item: T) => any): SortedJstream<T>;
    public thenByDescending(order: Order<T>): SortedJstream<T> {
        return new SortedJstream<T>(
            [...this.order, reverseOrder(order)],
            this.unsortedProperties,
            this.getUnsortedSource
        );
    }
}
